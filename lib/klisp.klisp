; core library

; aliases
(def and &)
(def or |)
(def xor ^)
(def not
     (fn (x)
         (if x false true)))
(def ! not)

; type assertions
(def nil?
     (fn (x) (= x ())))
(def number?
     (fn (x) (= (type x) 'number')))
(def boolean?
     (fn (x) (= (type x) 'boolean')))
(def string?
     (fn (x) (= (type x) 'string')))
(def function?
     (fn (x) (= (type x) 'function')))
(def list?
     (fn (x) (= (type x) 'composite')))

; identity
(def id
     (fn (x) x))

; basic math
(def neg
     (fn (n) (- 0 n)))
(def neg?
     (fn (n) (< n 0)))
(def abs
     (fn (n)
         (if (neg? n)
           (neg n)
           n)))
(def sign
     (fn (n)
         (if (neg? n)
           (neg 1)
           1)))
(def !=
     (fn (a b) (! (= a b))))
(def >=
     (fn (a b) (! (< a b))))
(def <=
     (fn (a b) (! (> a b))))
(def inc
     (fn (n) (+ n 1)))
(def dec
     (fn (n) (- n 1)))
(def sum
     (fn (ns) (reduce ns + 0)))
(def prod
     (fn (ns) (reduce ns * 1)))
(def times
     ; repeat x, n times in a list
     (fn (n x)
         (map (range 0 n 1)
              (fn () x))))

; list methods
(def list
     (macro (items)
            (cons (quote quote)
                  (cons items ()))))

(def append
     (fn (xs el)
         (if (nil? xs)
           (cons el ())
           (cons (car xs)
                 (append (cdr xs) el)))))

(def join
     (fn (xs ys)
         (if (nil? ys)
           xs
           (join (append xs (car ys))
                 (cdr ys)))))

(def range
     (fn (start end step)
         (do
           (def sub
                (fn (i acc)
                    (if (< i end)
                      (sub (+ i step)
                           (append acc i))
                      acc)))
           (sub start (list)))))

(def seq
     (fn (n) (range 0 n 1)))

(def map
     (fn (xs f)
         (if (nil? xs)
           ()
           (cons (f (car xs))
                 (map (cdr xs) f)))))

(def reduce
     (fn (xs f acc)
         (if (nil? xs)
           acc
           (reduce (cdr xs) f (f acc (car xs))))))

(def each
     (fn (xs f)
         (if (nil? xs)
           ()
           (do
             (f (car xs))
             (each (cdr xs) f)))))

(def size
     (fn (xs)
         (if (nil? xs)
           0
           (+ 1 (size (cdr xs))))))

