; core library

; aliases
(def and &)
(def or |)
(def xor ^)
(def not
     (fn (x)
         (if x false true)))
(def ! not)
(def caar
     (fn (x) (car (car x))))
(def cadr
     (fn (x) (car (cdr x))))
(def cddr
     (fn (x) (cdr (cdr x))))

; type assertions
(def nil?
     (fn (x) (= x ())))
(def zero?
     (fn (x) (= x 0)))
(def number?
     (fn (x) (= (type x) 'number')))
(def boolean?
     (fn (x) (= (type x) 'boolean')))
(def string?
     (fn (x) (= (type x) 'string')))
(def function?
     (fn (x) (= (type x) 'function')))
(def list?
     (fn (x) (= (type x) 'composite')))
(def pair?
     (fn (x)
         (if (list? x)
           (= (size x) 2)
           false)))

; identity
(def id
     (fn (x) x))

; basic math
(def neg
     (fn (n) (- 0 n)))
(def neg?
     (fn (n) (< n 0)))
(def abs
     (fn (n)
         (if (neg? n)
           (neg n)
           n)))
(def sign
     (fn (n)
         (if (neg? n)
           (neg 1)
           1)))
(def sqrt
     (fn (n) (# n 0.5)))
(def !=
     (fn (a b) (! (= a b))))
(def >=
     (fn (a b) (! (< a b))))
(def <=
     (fn (a b) (! (> a b))))
(def inc
     (fn (n) (+ n 1)))
(def dec
     (fn (n) (- n 1)))
(def sum
     (fn (ns) (reduce ns + 0)))
(def prod
     (fn (ns) (reduce ns * 1)))
(def times
     ; repeat x, n times in a list
     (fn (n x)
         (map (range 0 n 1)
              (fn () x))))

; macros
(def when
     (macro (terms)
            (list ,if (car terms) (cadr terms) ())))

(def unless
     (macro (terms)
            (list ,if (car terms) () (cadr terms))))

(def let
     (macro (terms)
            (do
              (def decl (car terms))
              (def declname (car decl))
              (def declval (cadr decl))
              (def body (cadr terms))
              (list
                (list ,fn (list declname) body)
                declval))))

(def lister
     (fn (items)
         (if (nil? items)
           ()
           (cons ,cons
                 (cons (car items)
                       (cons (lister (cdr items))
                             ()))))))
(def list
     (macro (items) (lister items)))

(def quasiquoter
     (fn (terms)
         (do
           (def qq (fn (term)
                       (if (list? term)
                         (if (= ,unquote (car term))
                           (cadr term)
                           (list ,quasiquote term))
                         (list ,quote term))))
           (map terms qq))))
(def quasiquote
     (macro (terms)
            (cons ,list
                  (quasiquoter (car terms)))))

(def do-times
     (macro (terms)
            (cons ,do
                  (times (car terms) (list (cadr terms))))))

; list methods
(def nth
     (fn (xs i)
         (if (zero? i)
           (car xs)
           (nth (cdr xs) (dec i)))))

(def matches-at?
     (fn (xs x i)
         (if (zero? i)
           (= (car xs) x)
           (matches-at? (cdr xs) x (dec i)))))

(def index
     (fn (xs x)
         (do
           (def index-from (fn (xs x rest)
                               (if (= (car xs) x)
                                 rest
                                 (index-from (cdr xs) x (inc rest)))))
           (index-from xs x 0))))

(def contains?
     (fn (xs x)
         (< 0 (index xs x))))

(def append
     (fn (xs el)
         (if (nil? xs)
           (list el)
           (cons (car xs)
                 (append (cdr xs) el)))))

(def join
     (fn (xs ys)
         (if (nil? ys)
           xs
           (join (append xs (car ys))
                 (cdr ys)))))

(def range
     (fn (start end step)
         (do
           (def sub
                (fn (i acc)
                    (if (< i end)
                      (sub (+ i step)
                           (append acc i))
                      acc)))
           (sub start (list)))))

(def seq
     (fn (n) (range 0 n 1)))

(def map
     (fn (xs f)
         (if (nil? xs)
           ()
           (cons (f (car xs))
                 (map (cdr xs) f)))))

(def map-deep
     (fn (xs f)
         (map xs (fn (x)
                     (if (list? x)
                       (map-deep x f)
                       (f x))))))

(def reduce
     (fn (xs f acc)
         (if (nil? xs)
           acc
           (reduce (cdr xs) f (f acc (car xs))))))

(def filter
     (fn (xs f)
         (if (nil? xs)
           ()
           (if (f (car xs))
             (cons (car xs)
                   (filter (cdr xs) f))
             (filter (cdr xs) f)))))

(def each
     (fn (xs f)
         (if (nil? xs)
           ()
           (do
             (f (car xs))
             (each (cdr xs) f)))))

(def size
     (fn (xs)
         (if (nil? xs)
           0
           (inc (size (cdr xs))))))

; utilities
(def comment
     ; add "(comment val)" to an expr head
     ; to substitute the expr with "val"
     (macro (terms) (car terms)))

(def log-runtime
     ; prints runtime (finish - start) of an expression
     (macro (terms)
            (list ,do
                  ,(def start (time))
                  (list ,def ,-val (cadr terms))
                  (list ,print
                        (list ,+ 'Runtime [' (car terms) ']:')
                        ,(number->string
                           (* 1000 (- (time) start)))
                        'ms')
                  ,-val)))

